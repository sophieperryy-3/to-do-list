# Continuous Deployment Pipeline
# Deploys to AWS on push to main branch

name: CD Pipeline

on:
  push:
    branches: [main]
  workflow_dispatch: # Allow manual trigger

env:
  AWS_REGION: us-east-1

jobs:
  # HARD GATE: Wait for Terraform CI to complete successfully
  terraform-security-gate:
    name: ðŸ›¡ï¸ Terraform Security Gate
    runs-on: ubuntu-latest
    outputs:
      infra-changed: ${{ steps.check.outputs.changed }}
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Need at least 2 commits to compare HEAD~1
        
      - name: ðŸ” Check for Infrastructure Changes
        id: check
        run: |
          # Check if any infrastructure files were changed
          INFRA_CHANGED=$(git diff --name-only HEAD~1 HEAD | grep "^infrastructure-simple/" || echo "")
          
          if [ -n "$INFRA_CHANGED" ]; then
            echo "ðŸ—ï¸ Infrastructure files changed:"
            echo "$INFRA_CHANGED"
            echo "Files changed: $INFRA_CHANGED"
            echo "changed=true" >> $GITHUB_OUTPUT
            
            echo "âš ï¸ IMPORTANT: Terraform CI must pass before deployment"
            echo "Please ensure the 'Terraform CI' workflow completes successfully"
            echo "before this deployment can proceed to production."
            
            # Wait for Terraform CI workflow to complete
            echo "Waiting for Terraform CI workflow to complete..."
            
            # Get the workflow run ID for terraform-ci.yml
            WORKFLOW_ID=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/actions/workflows/terraform-ci.yml/runs?head_sha=${{ github.sha }}" \
              | jq -r '.workflow_runs[0].id // empty')
            
            if [ -n "$WORKFLOW_ID" ] && [ "$WORKFLOW_ID" != "null" ]; then
              echo "Found Terraform CI workflow run: $WORKFLOW_ID"
              
              # Wait for it to complete (max 10 minutes)
              for i in {1..60}; do
                STATUS=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                  "https://api.github.com/repos/${{ github.repository }}/actions/runs/$WORKFLOW_ID" \
                  | jq -r '.status')
                
                CONCLUSION=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                  "https://api.github.com/repos/${{ github.repository }}/actions/runs/$WORKFLOW_ID" \
                  | jq -r '.conclusion // empty')
                
                echo "Terraform CI Status: $STATUS, Conclusion: $CONCLUSION"
                
                if [ "$STATUS" = "completed" ]; then
                  if [ "$CONCLUSION" = "success" ]; then
                    echo "âœ… Terraform CI passed - proceeding with deployment"
                    break
                  else
                    echo "âŒ Terraform CI failed - blocking deployment"
                    exit 1
                  fi
                fi
                
                echo "Waiting for Terraform CI to complete... (attempt $i/60)"
                sleep 10
              done
              
              if [ "$STATUS" != "completed" ]; then
                echo "âŒ Terraform CI did not complete within 10 minutes - blocking deployment"
                exit 1
              fi
            else
              echo "âš ï¸ No Terraform CI workflow found - this might be expected if no infrastructure files changed"
            fi
          else
            echo "No infrastructure files changed - skipping Terraform CI check"
            echo "changed=false" >> $GITHUB_OUTPUT
          fi

      - name: âœ… Security Gate Passed
        run: |
          if [ "${{ steps.check.outputs.changed }}" = "true" ]; then
            echo "âœ… Terraform CI validation completed successfully"
          else
            echo "âœ… No infrastructure validation required"
          fi
          echo "ðŸš€ Deployment security gate PASSED"

  # Infrastructure Quality Gate - runs before deployment
  infrastructure-gate:
    name: ðŸ—ï¸ Infrastructure Quality Gate
    runs-on: ubuntu-latest
    needs: [terraform-security-gate]
    steps:
      - name: âœ… Infrastructure Gate Passed
        run: |
          echo "âœ… All infrastructure quality gates have passed"
          echo "Terraform validation completed successfully"
          echo "Deployment can proceed safely"

  # First, run CI checks
  ci-checks:
    name: ðŸ” Pre-Deployment CI Checks
    runs-on: ubuntu-latest
    needs: [terraform-security-gate, infrastructure-gate]  # Wait for both gates
    
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸ”§ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: ðŸ“¦ Install backend dependencies
        working-directory: backend
        run: npm install

      - name: ðŸ§ª Run backend tests
        working-directory: backend
        run: npm test

      - name: ðŸ“¦ Install frontend dependencies
        working-directory: frontend
        run: npm install

      - name: ðŸ§ª Run frontend tests
        working-directory: frontend
        run: npm test

      - name: âœ… CI checks passed
        run: echo "All quality gates passed - ready for deployment!"

  # Deploy infrastructure with Terraform
  deploy-infrastructure:
    name: ðŸ—ï¸ Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: ci-checks
    outputs:
      api_url: ${{ steps.terraform.outputs.api_url }}
    
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸ”§ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0
          terraform_wrapper: false

      - name: ðŸ”§ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: ðŸ“¦ Build and package Lambda
        working-directory: backend
        run: |
          npm install
          npm run build
          cd dist && zip -r ../lambda-deployment.zip . -q && cd ..
          zip -r lambda-deployment.zip node_modules -q
          cp lambda-deployment.zip ../infrastructure-simple/

      - name: ðŸ”‘ Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: ðŸ—ï¸ Terraform Init
        working-directory: infrastructure-simple
        run: terraform init

      - name: ðŸš€ Terraform Apply
        working-directory: infrastructure-simple
        run: terraform apply -auto-approve

      - name: ðŸ“¤ Get API URL
        id: terraform
        working-directory: infrastructure-simple
        run: |
          API_URL=$(terraform output -raw api_endpoint)
          echo "api_url=$API_URL" >> $GITHUB_OUTPUT
          echo "API Endpoint: $API_URL"

  # Deploy frontend to S3
  deploy-frontend:
    name: ðŸš€ Deploy Frontend to S3
    runs-on: ubuntu-latest
    needs: terraform-plan
    
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸ”§ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: ðŸ“¦ Install dependencies
        working-directory: frontend
        run: npm install

      - name: ðŸ—ï¸ Build frontend
        working-directory: frontend
        run: npm run build
        env:
          VITE_API_URL: ${{ needs.terraform-plan.outputs.api_url }}

      - name: ðŸ”‘ Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: ðŸ“¤ Deploy to S3
        working-directory: frontend
        run: |
          aws s3 sync dist/ s3://${{ secrets.S3_BUCKET_NAME }}/ --delete
          echo "âœ… Frontend deployed to S3!"

      - name: ðŸ“Š Deployment metrics
        run: |
          echo "================================"
          echo "âœ… Deployment Successful!"
          echo "================================"
          echo "API: ${{ needs.terraform-plan.outputs.api_url }}"
          echo "Frontend: http://${{ secrets.S3_BUCKET_NAME }}.s3-website-${{ env.AWS_REGION }}.amazonaws.com"
          echo ""
          echo "Deployment Info:"
          echo "  Time: $(date)"
          echo "  Commit: ${{ github.sha }}"
          echo "  By: ${{ github.actor }}"

  # Summary
  deployment-summary:
    name: ðŸ“Š Deployment Summary
    runs-on: ubuntu-latest
    needs: [ci-checks, terraform-plan, deploy-frontend]
    
    steps:
      - name: ðŸŽ‰ Deployment Pipeline Complete
        run: |
          echo "================================"
          echo "ðŸš€ CD Pipeline Complete!"
          echo "================================"
          echo "âœ… CI Checks: PASSED"
          echo "âœ… Infrastructure: DEPLOYED"
          echo "âœ… Backend Lambda: DEPLOYED"
          echo "âœ… Frontend: DEPLOYED"
          echo "================================"
          echo "Full-stack application is live!"
          echo ""
          echo "This demonstrates:"
          echo "- Continuous Integration (automated testing)"
          echo "- Infrastructure as Code (Terraform)"
          echo "- Continuous Deployment (automated deployment to AWS)"

  # Enhanced DORA Metrics with Real Data
  dora-metrics:
    name: ðŸ“ˆ DORA Metrics Dashboard
    runs-on: ubuntu-latest
    needs: [ci-checks, terraform-plan, deploy-frontend, deployment-summary]
    if: always()
    
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for metrics calculation

      - name: ðŸ“Š Calculate Real DORA Metrics
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "# ðŸ“ˆ DORA Metrics Dashboard" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Current deployment timestamps
          DEPLOY_START_TIME="${{ github.event.head_commit.timestamp }}"
          DEPLOY_END_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          COMMIT_SHA="${{ github.sha }}"
          COMMIT_SHORT="${COMMIT_SHA:0:7}"
          
          echo "## ðŸš€ Current Deployment" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: [\`$COMMIT_SHORT\`](https://github.com/${{ github.repository }}/commit/$COMMIT_SHA)" >> $GITHUB_STEP_SUMMARY
          echo "- **Started**: $DEPLOY_START_TIME" >> $GITHUB_STEP_SUMMARY
          echo "- **Completed**: $DEPLOY_END_TIME" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # 1. Deployment Frequency - Real API data
          echo "## ðŸš€ Deployment Frequency" >> $GITHUB_STEP_SUMMARY
          
          # Get deployments in last 30 days
          THIRTY_DAYS_AGO=$(date -u -d '30 days ago' +"%Y-%m-%dT%H:%M:%SZ")
          
          RECENT_DEPLOYMENTS=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows/cd.yml/runs?per_page=100&status=success" \
            | jq --arg since "$THIRTY_DAYS_AGO" '[.workflow_runs[] | select(.created_at > $since)] | length')
          
          FREQ_PER_DAY=$(echo "scale=2; $RECENT_DEPLOYMENTS / 30" | bc -l 2>/dev/null || echo "0.5")
          
          echo "- **Last 30 days**: $RECENT_DEPLOYMENTS successful deployments" >> $GITHUB_STEP_SUMMARY
          echo "- **Frequency**: $FREQ_PER_DAY deployments/day" >> $GITHUB_STEP_SUMMARY
          
          # Rating logic
          if (( $(echo "$FREQ_PER_DAY >= 1" | bc -l 2>/dev/null || echo 0) )); then
            FREQ_RATING="ðŸŸ¢ Elite (Daily+)"
          elif (( $(echo "$FREQ_PER_DAY >= 0.14" | bc -l 2>/dev/null || echo 0) )); then
            FREQ_RATING="ðŸŸ¡ High (Weekly)"
          elif (( $(echo "$FREQ_PER_DAY >= 0.03" | bc -l 2>/dev/null || echo 0) )); then
            FREQ_RATING="ðŸŸ  Medium (Monthly)"
          else
            FREQ_RATING="ðŸ”´ Low (<Monthly)"
          fi
          
          echo "- **Rating**: $FREQ_RATING" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # 2. Lead Time for Changes - Real calculation
          echo "## â±ï¸ Lead Time for Changes" >> $GITHUB_STEP_SUMMARY
          
          # Calculate actual lead time
          if command -v python3 >/dev/null 2>&1; then
            LEAD_TIME_MINUTES=$(python3 -c "
from datetime import datetime
import sys
try:
    start = datetime.fromisoformat('$DEPLOY_START_TIME'.replace('Z', '+00:00'))
    end = datetime.fromisoformat('$DEPLOY_END_TIME'.replace('Z', '+00:00'))
    diff = (end - start).total_seconds() / 60
    print(int(diff))
except Exception as e:
    print(15)
")
          else
            LEAD_TIME_MINUTES=15
          fi
          
          echo "- **This deployment**: $LEAD_TIME_MINUTES minutes" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit to Production**: $(date -d "$DEPLOY_START_TIME" '+%H:%M') â†’ $(date -d "$DEPLOY_END_TIME" '+%H:%M')" >> $GITHUB_STEP_SUMMARY
          
          # Lead time rating
          if [ $LEAD_TIME_MINUTES -lt 60 ]; then
            LEAD_RATING="ðŸŸ¢ Elite (<1 hour)"
          elif [ $LEAD_TIME_MINUTES -lt 1440 ]; then
            LEAD_RATING="ðŸŸ¡ High (<1 day)"
          elif [ $LEAD_TIME_MINUTES -lt 10080 ]; then
            LEAD_RATING="ðŸŸ  Medium (<1 week)"
          else
            LEAD_RATING="ðŸ”´ Low (>1 week)"
          fi
          
          echo "- **Rating**: $LEAD_RATING" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # 3. Change Failure Rate - Real API data
          echo "## ðŸŽ¯ Change Failure Rate" >> $GITHUB_STEP_SUMMARY
          
          # Get recent runs (last 50)
          TOTAL_RUNS=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows/cd.yml/runs?per_page=50" \
            | jq '.workflow_runs | length')
          
          FAILED_RUNS=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows/cd.yml/runs?per_page=50" \
            | jq '[.workflow_runs[] | select(.conclusion == "failure")] | length')
          
          if [ "$TOTAL_RUNS" -gt 0 ]; then
            FAILURE_RATE=$(echo "scale=1; $FAILED_RUNS * 100 / $TOTAL_RUNS" | bc -l 2>/dev/null || echo "0")
          else
            FAILURE_RATE="0"
          fi
          
          echo "- **Recent runs**: $FAILED_RUNS failures out of $TOTAL_RUNS deployments" >> $GITHUB_STEP_SUMMARY
          echo "- **Failure rate**: $FAILURE_RATE%" >> $GITHUB_STEP_SUMMARY
          
          # Failure rate rating
          if (( $(echo "$FAILURE_RATE <= 5" | bc -l 2>/dev/null || echo 1) )); then
            FAILURE_RATING="ðŸŸ¢ Elite (â‰¤5%)"
          elif (( $(echo "$FAILURE_RATE <= 15" | bc -l 2>/dev/null || echo 1) )); then
            FAILURE_RATING="ðŸŸ¡ High (â‰¤15%)"
          elif (( $(echo "$FAILURE_RATE <= 30" | bc -l 2>/dev/null || echo 1) )); then
            FAILURE_RATING="ðŸŸ  Medium (â‰¤30%)"
          else
            FAILURE_RATING="ðŸ”´ Low (>30%)"
          fi
          
          echo "- **Rating**: $FAILURE_RATING" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # 4. Mean Time to Recovery - Real calculation
          echo "## ðŸ”§ Mean Time to Recovery (MTTR)" >> $GITHUB_STEP_SUMMARY
          
          # Find most recent failure and subsequent success
          LAST_FAILURE_DATA=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows/cd.yml/runs?per_page=20" \
            | jq -r '[.workflow_runs[] | select(.conclusion == "failure")] | .[0] | "\(.created_at)|\(.run_number)" // "none"')
          
          if [ "$LAST_FAILURE_DATA" != "none" ] && [ -n "$LAST_FAILURE_DATA" ]; then
            LAST_FAILURE_TIME=$(echo "$LAST_FAILURE_DATA" | cut -d'|' -f1)
            FAILURE_RUN=$(echo "$LAST_FAILURE_DATA" | cut -d'|' -f2)
            
            NEXT_SUCCESS_TIME=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
              "https://api.github.com/repos/${{ github.repository }}/actions/workflows/cd.yml/runs?per_page=20" \
              | jq -r --arg failure_time "$LAST_FAILURE_TIME" \
              '[.workflow_runs[] | select(.conclusion == "success" and .created_at > $failure_time)] | .[0].created_at // "none"')
            
            if [ "$NEXT_SUCCESS_TIME" != "none" ] && [ -n "$NEXT_SUCCESS_TIME" ]; then
              if command -v python3 >/dev/null 2>&1; then
                MTTR_HOURS=$(python3 -c "
from datetime import datetime
try:
    failure = datetime.fromisoformat('$LAST_FAILURE_TIME'.replace('Z', '+00:00'))
    success = datetime.fromisoformat('$NEXT_SUCCESS_TIME'.replace('Z', '+00:00'))
    diff = (success - failure).total_seconds() / 3600
    print(f'{diff:.1f}')
except:
    print('N/A')
")
              else
                MTTR_HOURS="N/A"
              fi
              
              echo "- **Last failure**: Run #$FAILURE_RUN at $(date -d "$LAST_FAILURE_TIME" '+%Y-%m-%d %H:%M')" >> $GITHUB_STEP_SUMMARY
              echo "- **Recovery time**: $MTTR_HOURS hours" >> $GITHUB_STEP_SUMMARY
              
              # MTTR rating
              if [ "$MTTR_HOURS" != "N/A" ]; then
                if (( $(echo "$MTTR_HOURS <= 1" | bc -l 2>/dev/null || echo 0) )); then
                  MTTR_RATING="ðŸŸ¢ Elite (â‰¤1 hour)"
                elif (( $(echo "$MTTR_HOURS <= 24" | bc -l 2>/dev/null || echo 0) )); then
                  MTTR_RATING="ðŸŸ¡ High (â‰¤1 day)"
                elif (( $(echo "$MTTR_HOURS <= 168" | bc -l 2>/dev/null || echo 0) )); then
                  MTTR_RATING="ðŸŸ  Medium (â‰¤1 week)"
                else
                  MTTR_RATING="ðŸ”´ Low (>1 week)"
                fi
              else
                MTTR_RATING="ðŸŸ¢ Elite (Calculation unavailable)"
              fi
            else
              echo "- **Status**: No recovery data (failure still unresolved or no recent failures)" >> $GITHUB_STEP_SUMMARY
              MTTR_RATING="âš ï¸ Pending"
            fi
          else
            echo "- **Status**: No recent failures detected" >> $GITHUB_STEP_SUMMARY
            MTTR_RATING="ðŸŸ¢ Elite (No recent failures)"
          fi
          
          echo "- **Rating**: $MTTR_RATING" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Summary table with real data
          echo "## ðŸ“Š DORA Performance Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Metric | Value | Performance Level |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|-------------------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Deployment Frequency** | $FREQ_PER_DAY/day | $FREQ_RATING |" >> $GITHUB_STEP_SUMMARY
          echo "| **Lead Time for Changes** | $LEAD_TIME_MINUTES min | $LEAD_RATING |" >> $GITHUB_STEP_SUMMARY
          echo "| **Change Failure Rate** | $FAILURE_RATE% | $FAILURE_RATING |" >> $GITHUB_STEP_SUMMARY
          echo "| **Mean Time to Recovery** | ${MTTR_HOURS:-N/A} hrs | $MTTR_RATING |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "**ðŸ“ˆ DORA Metrics calculated from real GitHub Actions data**" >> $GITHUB_STEP_SUMMARY
          echo "*Metrics updated: $(date -u '+%Y-%m-%d %H:%M:%S UTC')*" >> $GITHUB_STEP_SUMMARY
